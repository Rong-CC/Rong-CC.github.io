(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{405:function(n,e,t){"use strict";t.r(e);var i=t(54),o=Object(i.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"new-过程发生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-过程发生"}},[n._v("#")]),n._v(" new 过程发生")]),n._v(" "),t("ul",[t("li",[n._v("new Vue的时候调用会调用_init方法\n"),t("ul",[t("li",[n._v("定义 $set、$get 、$delete、$watch 等方法")]),n._v(" "),t("li",[n._v("定义 $on、$off、$emit、$off等事件")]),n._v(" "),t("li",[n._v("定义 _update、$forceUpdate、$destroy生命周期")])])]),n._v(" "),t("li",[n._v("调用$mount进行页面的挂载")]),n._v(" "),t("li",[n._v("挂载的时候主要是通过mountComponent方法")]),n._v(" "),t("li",[n._v("定义updateComponent更新函数")]),n._v(" "),t("li",[n._v("执行render生成虚拟DOM")]),n._v(" "),t("li",[n._v("_update将虚拟DOM生成真实DOM结构，并且渲染到页面中")])]),n._v(" "),t("p",[n._v("源码分析")]),n._v(" "),t("p",[n._v("首先找到vue 的构造函数")]),n._v(" "),t("p",[n._v("源码位置：src\\core\\instance\\index.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("import { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n/*Github:https://github.com/answershuto*/\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  /*初始化*/\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n")])])]),t("p",[n._v("options是用户传递过来的配置项，如data、methods等常用的方法")]),n._v(" "),t("p",[n._v("vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("initMixin(Vue);     // 定义 _init\nstateMixin(Vue);    // 定义 $set $get $delete $watch 等\neventsMixin(Vue);   // 定义事件  $on  $once $off $emit\nlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy\nrenderMixin(Vue);   // 定义 _render 返回虚拟dom\n")])])]),t("p",[n._v("查看initMixin方法 发现该方法在Vue原型上定义_init方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("/*initMixin就做了一件事情，在Vue的原型上增加_init方法，构造Vue实例的时候会调用这个_init方法来初始化Vue实例*/\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-init:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    /*一个防止vm实例自身被观察的标志位*/\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    /*初始化生命周期*/\n    initLifecycle(vm)\n    /*初始化事件*/\n    initEvents(vm)\n    /*初始化render*/\n    initRender(vm)\n    /*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    /*初始化props、methods、data、computed与watch*/\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    /*调用created钩子函数并且触发created钩子事件*/\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      /*格式化组件名*/\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`${vm._name} init`, startTag, endTag)\n    }\n\n    if (vm.$options.el) {\n      /*挂载组件*/\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n")])])]),t("p",[n._v("仔细阅读上面的代码，我们得到以下结论：")]),n._v(" "),t("ul",[t("li",[n._v("在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到")]),n._v(" "),t("li",[n._v("到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素")]),n._v(" "),t("li",[n._v("挂载方法是调用vm.$mount方法")])])])}),[],!1,null,null,null);e.default=o.exports}}]);